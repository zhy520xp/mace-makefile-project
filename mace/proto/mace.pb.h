// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mace/proto/mace.proto

#ifndef PROTOBUF_mace_2fproto_2fmace_2eproto__INCLUDED
#define PROTOBUF_mace_2fproto_2fmace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

//#if GOOGLE_PROTOBUF_VERSION < 3004000
//#error This file was generated by a newer version of protoc which is
//#error incompatible with your Protocol Buffer headers.  Please update
//#error your headers.
//#endif
//#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
//#error This file was generated by an older version of protoc which is
//#error incompatible with your Protocol Buffer headers.  Please
//#error regenerate this file with a newer version of protoc.
//#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
namespace mace {
class Argument;
class ArgumentDefaultTypeInternal;
extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class ConstTensor;
class ConstTensorDefaultTypeInternal;
extern ConstTensorDefaultTypeInternal _ConstTensor_default_instance_;
class InputInfo;
class InputInfoDefaultTypeInternal;
extern InputInfoDefaultTypeInternal _InputInfo_default_instance_;
class MemoryArena;
class MemoryArenaDefaultTypeInternal;
extern MemoryArenaDefaultTypeInternal _MemoryArena_default_instance_;
class MemoryBlock;
class MemoryBlockDefaultTypeInternal;
extern MemoryBlockDefaultTypeInternal _MemoryBlock_default_instance_;
class NetDef;
class NetDefDefaultTypeInternal;
extern NetDefDefaultTypeInternal _NetDef_default_instance_;
class NodeInput;
class NodeInputDefaultTypeInternal;
extern NodeInputDefaultTypeInternal _NodeInput_default_instance_;
class OperatorDef;
class OperatorDefDefaultTypeInternal;
extern OperatorDefDefaultTypeInternal _OperatorDef_default_instance_;
class OutputInfo;
class OutputInfoDefaultTypeInternal;
extern OutputInfoDefaultTypeInternal _OutputInfo_default_instance_;
class OutputShape;
class OutputShapeDefaultTypeInternal;
extern OutputShapeDefaultTypeInternal _OutputShape_default_instance_;
}  // namespace mace

namespace mace {

namespace protobuf_mace_2fproto_2fmace_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_mace_2fproto_2fmace_2eproto

enum NetMode {
  INIT = 0,
  NORMAL = 1
};
bool NetMode_IsValid(int value);
const NetMode NetMode_MIN = INIT;
const NetMode NetMode_MAX = NORMAL;
const int NetMode_ARRAYSIZE = NetMode_MAX + 1;

enum DataType {
  DT_INVALID = 0,
  DT_FLOAT = 1,
  DT_UINT8 = 2,
  DT_HALF = 3,
  DT_INT32 = 4
};
bool DataType_IsValid(int value);
const DataType DataType_MIN = DT_INVALID;
const DataType DataType_MAX = DT_INT32;
const int DataType_ARRAYSIZE = DataType_MAX + 1;

// ===================================================================

class ConstTensor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.ConstTensor) */ {
 public:
  ConstTensor();
  virtual ~ConstTensor();

  ConstTensor(const ConstTensor& from);

  inline ConstTensor& operator=(const ConstTensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConstTensor(ConstTensor&& from) noexcept
    : ConstTensor() {
    *this = ::std::move(from);
  }

  inline ConstTensor& operator=(ConstTensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ConstTensor& default_instance();

  static inline const ConstTensor* internal_default_instance() {
    return reinterpret_cast<const ConstTensor*>(
               &_ConstTensor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(ConstTensor* other);
  friend void swap(ConstTensor& a, ConstTensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConstTensor* New() const PROTOBUF_FINAL { return New(NULL); }

  ConstTensor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ConstTensor& from);
  void MergeFrom(const ConstTensor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConstTensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // repeated float float_data = 3 [packed = true];
  int float_data_size() const;
  void clear_float_data();
  static const int kFloatDataFieldNumber = 3;
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      float_data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  int int32_data_size() const;
  void clear_int32_data();
  static const int kInt32DataFieldNumber = 4;
  ::google::protobuf::int32 int32_data(int index) const;
  void set_int32_data(int index, ::google::protobuf::int32 value);
  void add_int32_data(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      int32_data() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_int32_data();

  // optional string name = 5;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 5;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int64 offset = 6;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 6;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // optional int64 data_size = 7;
  bool has_data_size() const;
  void clear_data_size();
  static const int kDataSizeFieldNumber = 7;
  ::google::protobuf::int64 data_size() const;
  void set_data_size(::google::protobuf::int64 value);

  // optional uint32 node_id = 100;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 100;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional .mace.DataType data_type = 2 [default = DT_FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::mace::DataType data_type() const;
  void set_data_type(::mace::DataType value);

  // @@protoc_insertion_point(class_scope:mace.ConstTensor)
 private:
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_name();
  void clear_has_name();
  void set_has_offset();
  void clear_has_offset();
  void set_has_data_size();
  void clear_has_data_size();
  void set_has_node_id();
  void clear_has_node_id();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::RepeatedField< float > float_data_;
  mutable int _float_data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > int32_data_;
  mutable int _int32_data_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 data_size_;
  ::google::protobuf::uint32 node_id_;
  int data_type_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Argument : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Argument& default_instance();

  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Argument* other);
  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const PROTOBUF_FINAL { return New(NULL); }

  Argument* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Argument* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float floats = 5;
  int floats_size() const;
  void clear_floats();
  static const int kFloatsFieldNumber = 5;
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::google::protobuf::RepeatedField< float >&
      floats() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 6;
  int ints_size() const;
  void clear_ints();
  static const int kIntsFieldNumber = 6;
  ::google::protobuf::int64 ints(int index) const;
  void set_ints(int index, ::google::protobuf::int64 value);
  void add_ints(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      ints() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_ints();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes s = 4;
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 4;
  const ::std::string& s() const;
  void set_s(const ::std::string& value);
  #if LANG_CXX11
  void set_s(::std::string&& value);
  #endif
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  ::std::string* mutable_s();
  ::std::string* release_s();
  void set_allocated_s(::std::string* s);

  // optional int64 i = 3;
  bool has_i() const;
  void clear_i();
  static const int kIFieldNumber = 3;
  ::google::protobuf::int64 i() const;
  void set_i(::google::protobuf::int64 value);

  // optional float f = 2;
  bool has_f() const;
  void clear_f();
  static const int kFFieldNumber = 2;
  float f() const;
  void set_f(float value);

  // @@protoc_insertion_point(class_scope:mace.Argument)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_f();
  void clear_has_f();
  void set_has_i();
  void clear_has_i();
  void set_has_s();
  void clear_has_s();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > floats_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > ints_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr s_;
  ::google::protobuf::int64 i_;
  float f_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeInput : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.NodeInput) */ {
 public:
  NodeInput();
  virtual ~NodeInput();

  NodeInput(const NodeInput& from);

  inline NodeInput& operator=(const NodeInput& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInput(NodeInput&& from) noexcept
    : NodeInput() {
    *this = ::std::move(from);
  }

  inline NodeInput& operator=(NodeInput&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NodeInput& default_instance();

  static inline const NodeInput* internal_default_instance() {
    return reinterpret_cast<const NodeInput*>(
               &_NodeInput_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(NodeInput* other);
  friend void swap(NodeInput& a, NodeInput& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInput* New() const PROTOBUF_FINAL { return New(NULL); }

  NodeInput* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NodeInput& from);
  void MergeFrom(const NodeInput& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeInput* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 node_id = 1;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  ::google::protobuf::int32 node_id() const;
  void set_node_id(::google::protobuf::int32 value);

  // optional int32 output_port = 2;
  bool has_output_port() const;
  void clear_output_port();
  static const int kOutputPortFieldNumber = 2;
  ::google::protobuf::int32 output_port() const;
  void set_output_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mace.NodeInput)
 private:
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_output_port();
  void clear_has_output_port();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 output_port_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputShape : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.OutputShape) */ {
 public:
  OutputShape();
  virtual ~OutputShape();

  OutputShape(const OutputShape& from);

  inline OutputShape& operator=(const OutputShape& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputShape(OutputShape&& from) noexcept
    : OutputShape() {
    *this = ::std::move(from);
  }

  inline OutputShape& operator=(OutputShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OutputShape& default_instance();

  static inline const OutputShape* internal_default_instance() {
    return reinterpret_cast<const OutputShape*>(
               &_OutputShape_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(OutputShape* other);
  friend void swap(OutputShape& a, OutputShape& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputShape* New() const PROTOBUF_FINAL { return New(NULL); }

  OutputShape* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OutputShape& from);
  void MergeFrom(const OutputShape& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutputShape* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 dims = 1;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 1;
  ::google::protobuf::int64 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int64 value);
  void add_dims(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // @@protoc_insertion_point(class_scope:mace.OutputShape)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OperatorDef : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.OperatorDef) */ {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OperatorDef(OperatorDef&& from) noexcept
    : OperatorDef() {
    *this = ::std::move(from);
  }

  inline OperatorDef& operator=(OperatorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OperatorDef& default_instance();

  static inline const OperatorDef* internal_default_instance() {
    return reinterpret_cast<const OperatorDef*>(
               &_OperatorDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(OperatorDef* other);
  friend void swap(OperatorDef& a, OperatorDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OperatorDef* New() const PROTOBUF_FINAL { return New(NULL); }

  OperatorDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OperatorDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string input = 1;
  int input_size() const;
  void clear_input();
  static const int kInputFieldNumber = 1;
  const ::std::string& input(int index) const;
  ::std::string* mutable_input(int index);
  void set_input(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_input(int index, ::std::string&& value);
  #endif
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  ::std::string* add_input();
  void add_input(const ::std::string& value);
  #if LANG_CXX11
  void add_input(::std::string&& value);
  #endif
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& input() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_input();

  // repeated string output = 2;
  int output_size() const;
  void clear_output();
  static const int kOutputFieldNumber = 2;
  const ::std::string& output(int index) const;
  ::std::string* mutable_output(int index);
  void set_output(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_output(int index, ::std::string&& value);
  #endif
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  ::std::string* add_output();
  void add_output(const ::std::string& value);
  #if LANG_CXX11
  void add_output(::std::string&& value);
  #endif
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& output() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_output();

  // repeated .mace.Argument arg = 5;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 5;
  const ::mace::Argument& arg(int index) const;
  ::mace::Argument* mutable_arg(int index);
  ::mace::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::mace::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
      arg() const;

  // repeated .mace.OutputShape output_shape = 6;
  int output_shape_size() const;
  void clear_output_shape();
  static const int kOutputShapeFieldNumber = 6;
  const ::mace::OutputShape& output_shape(int index) const;
  ::mace::OutputShape* mutable_output_shape(int index);
  ::mace::OutputShape* add_output_shape();
  ::google::protobuf::RepeatedPtrField< ::mace::OutputShape >*
      mutable_output_shape();
  const ::google::protobuf::RepeatedPtrField< ::mace::OutputShape >&
      output_shape() const;

  // repeated .mace.DataType output_type = 7;
  int output_type_size() const;
  void clear_output_type();
  static const int kOutputTypeFieldNumber = 7;
  ::mace::DataType output_type(int index) const;
  void set_output_type(int index, ::mace::DataType value);
  void add_output_type(::mace::DataType value);
  const ::google::protobuf::RepeatedField<int>& output_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_output_type();

  // repeated int32 mem_id = 10;
  int mem_id_size() const;
  void clear_mem_id();
  static const int kMemIdFieldNumber = 10;
  ::google::protobuf::int32 mem_id(int index) const;
  void set_mem_id(int index, ::google::protobuf::int32 value);
  void add_mem_id(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      mem_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_mem_id();

  // repeated .mace.NodeInput node_input = 103;
  int node_input_size() const;
  void clear_node_input();
  static const int kNodeInputFieldNumber = 103;
  const ::mace::NodeInput& node_input(int index) const;
  ::mace::NodeInput* mutable_node_input(int index);
  ::mace::NodeInput* add_node_input();
  ::google::protobuf::RepeatedPtrField< ::mace::NodeInput >*
      mutable_node_input();
  const ::google::protobuf::RepeatedPtrField< ::mace::NodeInput >&
      node_input() const;

  // repeated int32 out_max_byte_size = 104;
  int out_max_byte_size_size() const;
  void clear_out_max_byte_size();
  static const int kOutMaxByteSizeFieldNumber = 104;
  ::google::protobuf::int32 out_max_byte_size(int index) const;
  void set_out_max_byte_size(int index, ::google::protobuf::int32 value);
  void add_out_max_byte_size(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      out_max_byte_size() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_out_max_byte_size();

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional uint32 padding = 102;
  bool has_padding() const;
  void clear_padding();
  static const int kPaddingFieldNumber = 102;
  ::google::protobuf::uint32 padding() const;
  void set_padding(::google::protobuf::uint32 value);

  // optional uint32 node_id = 100;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 100;
  ::google::protobuf::uint32 node_id() const;
  void set_node_id(::google::protobuf::uint32 value);

  // optional uint32 op_id = 101;
  bool has_op_id() const;
  void clear_op_id();
  static const int kOpIdFieldNumber = 101;
  ::google::protobuf::uint32 op_id() const;
  void set_op_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mace.OperatorDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_op_id();
  void clear_has_op_id();
  void set_has_padding();
  void clear_has_padding();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> input_;
  ::google::protobuf::RepeatedPtrField< ::std::string> output_;
  ::google::protobuf::RepeatedPtrField< ::mace::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::mace::OutputShape > output_shape_;
  ::google::protobuf::RepeatedField<int> output_type_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > mem_id_;
  ::google::protobuf::RepeatedPtrField< ::mace::NodeInput > node_input_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > out_max_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint32 padding_;
  ::google::protobuf::uint32 node_id_;
  ::google::protobuf::uint32 op_id_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemoryBlock : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.MemoryBlock) */ {
 public:
  MemoryBlock();
  virtual ~MemoryBlock();

  MemoryBlock(const MemoryBlock& from);

  inline MemoryBlock& operator=(const MemoryBlock& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemoryBlock(MemoryBlock&& from) noexcept
    : MemoryBlock() {
    *this = ::std::move(from);
  }

  inline MemoryBlock& operator=(MemoryBlock&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MemoryBlock& default_instance();

  static inline const MemoryBlock* internal_default_instance() {
    return reinterpret_cast<const MemoryBlock*>(
               &_MemoryBlock_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(MemoryBlock* other);
  friend void swap(MemoryBlock& a, MemoryBlock& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoryBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  MemoryBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MemoryBlock& from);
  void MergeFrom(const MemoryBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 mem_id = 1;
  bool has_mem_id() const;
  void clear_mem_id();
  static const int kMemIdFieldNumber = 1;
  ::google::protobuf::int32 mem_id() const;
  void set_mem_id(::google::protobuf::int32 value);

  // optional uint32 x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mace.MemoryBlock)
 private:
  void set_has_mem_id();
  void clear_has_mem_id();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 mem_id_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MemoryArena : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.MemoryArena) */ {
 public:
  MemoryArena();
  virtual ~MemoryArena();

  MemoryArena(const MemoryArena& from);

  inline MemoryArena& operator=(const MemoryArena& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MemoryArena(MemoryArena&& from) noexcept
    : MemoryArena() {
    *this = ::std::move(from);
  }

  inline MemoryArena& operator=(MemoryArena&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const MemoryArena& default_instance();

  static inline const MemoryArena* internal_default_instance() {
    return reinterpret_cast<const MemoryArena*>(
               &_MemoryArena_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MemoryArena* other);
  friend void swap(MemoryArena& a, MemoryArena& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MemoryArena* New() const PROTOBUF_FINAL { return New(NULL); }

  MemoryArena* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const MemoryArena& from);
  void MergeFrom(const MemoryArena& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MemoryArena* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mace.MemoryBlock mem_block = 1;
  int mem_block_size() const;
  void clear_mem_block();
  static const int kMemBlockFieldNumber = 1;
  const ::mace::MemoryBlock& mem_block(int index) const;
  ::mace::MemoryBlock* mutable_mem_block(int index);
  ::mace::MemoryBlock* add_mem_block();
  ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >*
      mutable_mem_block();
  const ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >&
      mem_block() const;

  // @@protoc_insertion_point(class_scope:mace.MemoryArena)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock > mem_block_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InputInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.InputInfo) */ {
 public:
  InputInfo();
  virtual ~InputInfo();

  InputInfo(const InputInfo& from);

  inline InputInfo& operator=(const InputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputInfo(InputInfo&& from) noexcept
    : InputInfo() {
    *this = ::std::move(from);
  }

  inline InputInfo& operator=(InputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const InputInfo& default_instance();

  static inline const InputInfo* internal_default_instance() {
    return reinterpret_cast<const InputInfo*>(
               &_InputInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(InputInfo* other);
  friend void swap(InputInfo& a, InputInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  InputInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const InputInfo& from);
  void MergeFrom(const InputInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 dims = 3;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 3;
  ::google::protobuf::int32 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int32 value);
  void add_dims(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dims();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 node_id = 2;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::int32 node_id() const;
  void set_node_id(::google::protobuf::int32 value);

  // optional int32 max_byte_size = 4;
  bool has_max_byte_size() const;
  void clear_max_byte_size();
  static const int kMaxByteSizeFieldNumber = 4;
  ::google::protobuf::int32 max_byte_size() const;
  void set_max_byte_size(::google::protobuf::int32 value);

  // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 5;
  ::mace::DataType data_type() const;
  void set_data_type(::mace::DataType value);

  // @@protoc_insertion_point(class_scope:mace.InputInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_max_byte_size();
  void clear_has_max_byte_size();
  void set_has_data_type();
  void clear_has_data_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dims_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 max_byte_size_;
  int data_type_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OutputInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.OutputInfo) */ {
 public:
  OutputInfo();
  virtual ~OutputInfo();

  OutputInfo(const OutputInfo& from);

  inline OutputInfo& operator=(const OutputInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OutputInfo(OutputInfo&& from) noexcept
    : OutputInfo() {
    *this = ::std::move(from);
  }

  inline OutputInfo& operator=(OutputInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const OutputInfo& default_instance();

  static inline const OutputInfo* internal_default_instance() {
    return reinterpret_cast<const OutputInfo*>(
               &_OutputInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(OutputInfo* other);
  friend void swap(OutputInfo& a, OutputInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OutputInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  OutputInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const OutputInfo& from);
  void MergeFrom(const OutputInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutputInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 dims = 3;
  int dims_size() const;
  void clear_dims();
  static const int kDimsFieldNumber = 3;
  ::google::protobuf::int32 dims(int index) const;
  void set_dims(int index, ::google::protobuf::int32 value);
  void add_dims(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dims() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dims();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 node_id = 2;
  bool has_node_id() const;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  ::google::protobuf::int32 node_id() const;
  void set_node_id(::google::protobuf::int32 value);

  // optional int32 max_byte_size = 4;
  bool has_max_byte_size() const;
  void clear_max_byte_size();
  static const int kMaxByteSizeFieldNumber = 4;
  ::google::protobuf::int32 max_byte_size() const;
  void set_max_byte_size(::google::protobuf::int32 value);

  // optional .mace.DataType data_type = 5 [default = DT_FLOAT];
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 5;
  ::mace::DataType data_type() const;
  void set_data_type(::mace::DataType value);

  // @@protoc_insertion_point(class_scope:mace.OutputInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_node_id();
  void clear_has_node_id();
  void set_has_max_byte_size();
  void clear_has_max_byte_size();
  void set_has_data_type();
  void clear_has_data_type();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dims_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 node_id_;
  ::google::protobuf::int32 max_byte_size_;
  int data_type_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NetDef : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mace.NetDef) */ {
 public:
  NetDef();
  virtual ~NetDef();

  NetDef(const NetDef& from);

  inline NetDef& operator=(const NetDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetDef(NetDef&& from) noexcept
    : NetDef() {
    *this = ::std::move(from);
  }

  inline NetDef& operator=(NetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const NetDef& default_instance();

  static inline const NetDef* internal_default_instance() {
    return reinterpret_cast<const NetDef*>(
               &_NetDef_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(NetDef* other);
  friend void swap(NetDef& a, NetDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetDef* New() const PROTOBUF_FINAL { return New(NULL); }

  NetDef* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const NetDef& from);
  void MergeFrom(const NetDef& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NetDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mace.OperatorDef op = 2;
  int op_size() const;
  void clear_op();
  static const int kOpFieldNumber = 2;
  const ::mace::OperatorDef& op(int index) const;
  ::mace::OperatorDef* mutable_op(int index);
  ::mace::OperatorDef* add_op();
  ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >*
      mutable_op();
  const ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >&
      op() const;

  // repeated .mace.Argument arg = 4;
  int arg_size() const;
  void clear_arg();
  static const int kArgFieldNumber = 4;
  const ::mace::Argument& arg(int index) const;
  ::mace::Argument* mutable_arg(int index);
  ::mace::Argument* add_arg();
  ::google::protobuf::RepeatedPtrField< ::mace::Argument >*
      mutable_arg();
  const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
      arg() const;

  // repeated .mace.ConstTensor tensors = 5;
  int tensors_size() const;
  void clear_tensors();
  static const int kTensorsFieldNumber = 5;
  const ::mace::ConstTensor& tensors(int index) const;
  ::mace::ConstTensor* mutable_tensors(int index);
  ::mace::ConstTensor* add_tensors();
  ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >*
      mutable_tensors();
  const ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >&
      tensors() const;

  // repeated .mace.InputInfo input_info = 100;
  int input_info_size() const;
  void clear_input_info();
  static const int kInputInfoFieldNumber = 100;
  const ::mace::InputInfo& input_info(int index) const;
  ::mace::InputInfo* mutable_input_info(int index);
  ::mace::InputInfo* add_input_info();
  ::google::protobuf::RepeatedPtrField< ::mace::InputInfo >*
      mutable_input_info();
  const ::google::protobuf::RepeatedPtrField< ::mace::InputInfo >&
      input_info() const;

  // repeated .mace.OutputInfo output_info = 101;
  int output_info_size() const;
  void clear_output_info();
  static const int kOutputInfoFieldNumber = 101;
  const ::mace::OutputInfo& output_info(int index) const;
  ::mace::OutputInfo* mutable_output_info(int index);
  ::mace::OutputInfo* add_output_info();
  ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >*
      mutable_output_info();
  const ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >&
      output_info() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string version = 3;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // optional .mace.MemoryArena mem_arena = 10;
  bool has_mem_arena() const;
  void clear_mem_arena();
  static const int kMemArenaFieldNumber = 10;
  const ::mace::MemoryArena& mem_arena() const;
  ::mace::MemoryArena* mutable_mem_arena();
  ::mace::MemoryArena* release_mem_arena();
  void set_allocated_mem_arena(::mace::MemoryArena* mem_arena);

  // @@protoc_insertion_point(class_scope:mace.NetDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_version();
  void clear_has_version();
  void set_has_mem_arena();
  void clear_has_mem_arena();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef > op_;
  ::google::protobuf::RepeatedPtrField< ::mace::Argument > arg_;
  ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor > tensors_;
  ::google::protobuf::RepeatedPtrField< ::mace::InputInfo > input_info_;
  ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo > output_info_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::mace::MemoryArena* mem_arena_;
  friend struct protobuf_mace_2fproto_2fmace_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConstTensor

// repeated int64 dims = 1;
inline int ConstTensor::dims_size() const {
  return dims_.size();
}
inline void ConstTensor::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 ConstTensor::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.dims)
  return dims_.Get(index);
}
inline void ConstTensor::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.dims)
}
inline void ConstTensor::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ConstTensor::dims() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ConstTensor::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.dims)
  return &dims_;
}

// optional .mace.DataType data_type = 2 [default = DT_FLOAT];
inline bool ConstTensor::has_data_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConstTensor::set_has_data_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConstTensor::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConstTensor::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::mace::DataType ConstTensor::data_type() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
inline void ConstTensor::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_type)
}

// repeated float float_data = 3 [packed = true];
inline int ConstTensor::float_data_size() const {
  return float_data_.size();
}
inline void ConstTensor::clear_float_data() {
  float_data_.Clear();
}
inline float ConstTensor::float_data(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.float_data)
  return float_data_.Get(index);
}
inline void ConstTensor::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.float_data)
}
inline void ConstTensor::add_float_data(float value) {
  float_data_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.float_data)
}
inline const ::google::protobuf::RepeatedField< float >&
ConstTensor::float_data() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.float_data)
  return float_data_;
}
inline ::google::protobuf::RepeatedField< float >*
ConstTensor::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.float_data)
  return &float_data_;
}

// repeated int32 int32_data = 4 [packed = true];
inline int ConstTensor::int32_data_size() const {
  return int32_data_.size();
}
inline void ConstTensor::clear_int32_data() {
  int32_data_.Clear();
}
inline ::google::protobuf::int32 ConstTensor::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.int32_data)
  return int32_data_.Get(index);
}
inline void ConstTensor::set_int32_data(int index, ::google::protobuf::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.int32_data)
}
inline void ConstTensor::add_int32_data(::google::protobuf::int32 value) {
  int32_data_.Add(value);
  // @@protoc_insertion_point(field_add:mace.ConstTensor.int32_data)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConstTensor::int32_data() const {
  // @@protoc_insertion_point(field_list:mace.ConstTensor.int32_data)
  return int32_data_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConstTensor::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:mace.ConstTensor.int32_data)
  return &int32_data_;
}

// optional string name = 5;
inline bool ConstTensor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConstTensor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConstTensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConstTensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ConstTensor::name() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.name)
  return name_.GetNoArena();
}
inline void ConstTensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.ConstTensor.name)
}
#if LANG_CXX11
inline void ConstTensor::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.ConstTensor.name)
}
#endif
inline void ConstTensor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.ConstTensor.name)
}
inline void ConstTensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.ConstTensor.name)
}
inline ::std::string* ConstTensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.ConstTensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConstTensor::release_name() {
  // @@protoc_insertion_point(field_release:mace.ConstTensor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConstTensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.ConstTensor.name)
}

// optional int64 offset = 6;
inline bool ConstTensor::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConstTensor::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConstTensor::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConstTensor::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 ConstTensor::offset() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.offset)
  return offset_;
}
inline void ConstTensor::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.offset)
}

// optional int64 data_size = 7;
inline bool ConstTensor::has_data_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConstTensor::set_has_data_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConstTensor::clear_has_data_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConstTensor::clear_data_size() {
  data_size_ = GOOGLE_LONGLONG(0);
  clear_has_data_size();
}
inline ::google::protobuf::int64 ConstTensor::data_size() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.data_size)
  return data_size_;
}
inline void ConstTensor::set_data_size(::google::protobuf::int64 value) {
  set_has_data_size();
  data_size_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.data_size)
}

// optional uint32 node_id = 100;
inline bool ConstTensor::has_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConstTensor::set_has_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConstTensor::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConstTensor::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 ConstTensor::node_id() const {
  // @@protoc_insertion_point(field_get:mace.ConstTensor.node_id)
  return node_id_;
}
inline void ConstTensor::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.ConstTensor.node_id)
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Argument::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Argument::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:mace.Argument.name)
  return name_.GetNoArena();
}
inline void Argument::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.Argument.name)
}
#if LANG_CXX11
inline void Argument::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.Argument.name)
}
#endif
inline void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.Argument.name)
}
inline ::std::string* Argument::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.Argument.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:mace.Argument.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.Argument.name)
}

// optional float f = 2;
inline bool Argument::has_f() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Argument::set_has_f() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Argument::clear_has_f() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Argument::clear_f() {
  f_ = 0;
  clear_has_f();
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:mace.Argument.f)
  return f_;
}
inline void Argument::set_f(float value) {
  set_has_f();
  f_ = value;
  // @@protoc_insertion_point(field_set:mace.Argument.f)
}

// optional int64 i = 3;
inline bool Argument::has_i() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Argument::set_has_i() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Argument::clear_has_i() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Argument::clear_i() {
  i_ = GOOGLE_LONGLONG(0);
  clear_has_i();
}
inline ::google::protobuf::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:mace.Argument.i)
  return i_;
}
inline void Argument::set_i(::google::protobuf::int64 value) {
  set_has_i();
  i_ = value;
  // @@protoc_insertion_point(field_set:mace.Argument.i)
}

// optional bytes s = 4;
inline bool Argument::has_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Argument::set_has_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Argument::clear_has_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_s();
}
inline const ::std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:mace.Argument.s)
  return s_.GetNoArena();
}
inline void Argument::set_s(const ::std::string& value) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.Argument.s)
}
#if LANG_CXX11
inline void Argument::set_s(::std::string&& value) {
  set_has_s();
  s_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.Argument.s)
}
#endif
inline void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.Argument.s)
}
inline void Argument::set_s(const void* value, size_t size) {
  set_has_s();
  s_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.Argument.s)
}
inline ::std::string* Argument::mutable_s() {
  set_has_s();
  // @@protoc_insertion_point(field_mutable:mace.Argument.s)
  return s_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:mace.Argument.s)
  clear_has_s();
  return s_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s(::std::string* s) {
  if (s != NULL) {
    set_has_s();
  } else {
    clear_has_s();
  }
  s_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:mace.Argument.s)
}

// repeated float floats = 5;
inline int Argument::floats_size() const {
  return floats_.size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:mace.Argument.floats)
  return floats_.Get(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.Argument.floats)
}
inline void Argument::add_floats(float value) {
  floats_.Add(value);
  // @@protoc_insertion_point(field_add:mace.Argument.floats)
}
inline const ::google::protobuf::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:mace.Argument.floats)
  return floats_;
}
inline ::google::protobuf::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:mace.Argument.floats)
  return &floats_;
}

// repeated int64 ints = 6;
inline int Argument::ints_size() const {
  return ints_.size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::google::protobuf::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:mace.Argument.ints)
  return ints_.Get(index);
}
inline void Argument::set_ints(int index, ::google::protobuf::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.Argument.ints)
}
inline void Argument::add_ints(::google::protobuf::int64 value) {
  ints_.Add(value);
  // @@protoc_insertion_point(field_add:mace.Argument.ints)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:mace.Argument.ints)
  return ints_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:mace.Argument.ints)
  return &ints_;
}

// -------------------------------------------------------------------

// NodeInput

// optional int32 node_id = 1;
inline bool NodeInput::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeInput::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeInput::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeInput::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 NodeInput::node_id() const {
  // @@protoc_insertion_point(field_get:mace.NodeInput.node_id)
  return node_id_;
}
inline void NodeInput::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.NodeInput.node_id)
}

// optional int32 output_port = 2;
inline bool NodeInput::has_output_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeInput::set_has_output_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeInput::clear_has_output_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeInput::clear_output_port() {
  output_port_ = 0;
  clear_has_output_port();
}
inline ::google::protobuf::int32 NodeInput::output_port() const {
  // @@protoc_insertion_point(field_get:mace.NodeInput.output_port)
  return output_port_;
}
inline void NodeInput::set_output_port(::google::protobuf::int32 value) {
  set_has_output_port();
  output_port_ = value;
  // @@protoc_insertion_point(field_set:mace.NodeInput.output_port)
}

// -------------------------------------------------------------------

// OutputShape

// repeated int64 dims = 1;
inline int OutputShape::dims_size() const {
  return dims_.size();
}
inline void OutputShape::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 OutputShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.OutputShape.dims)
  return dims_.Get(index);
}
inline void OutputShape::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OutputShape.dims)
}
inline void OutputShape::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OutputShape.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
OutputShape::dims() const {
  // @@protoc_insertion_point(field_list:mace.OutputShape.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
OutputShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.OutputShape.dims)
  return &dims_;
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::input_size() const {
  return input_.size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline const ::std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.input)
  return input_.Get(index);
}
inline ::std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_input(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.input)
}
inline ::std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:mace.OperatorDef.input)
  return input_.Add();
}
inline void OperatorDef::add_input(const ::std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.input)
}
#if LANG_CXX11
inline void OperatorDef::add_input(::std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mace.OperatorDef.input)
}
#endif
inline void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mace.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mace.OperatorDef.input)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.input)
  return input_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::output_size() const {
  return output_.size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline const ::std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output)
  return output_.Get(index);
}
inline ::std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void OperatorDef::set_output(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
#endif
inline void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.output)
}
inline ::std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:mace.OperatorDef.output)
  return output_.Add();
}
inline void OperatorDef::add_output(const ::std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output)
}
#if LANG_CXX11
inline void OperatorDef::add_output(::std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output)
}
#endif
inline void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mace.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mace.OperatorDef.output)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output)
  return output_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OperatorDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OperatorDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.name)
  return name_.GetNoArena();
}
inline void OperatorDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.name)
}
#if LANG_CXX11
inline void OperatorDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OperatorDef.name)
}
#endif
inline void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.name)
}
inline ::std::string* OperatorDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:mace.OperatorDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OperatorDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OperatorDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.type)
  return type_.GetNoArena();
}
inline void OperatorDef::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.type)
}
#if LANG_CXX11
inline void OperatorDef::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OperatorDef.type)
}
#endif
inline void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OperatorDef.type)
}
inline ::std::string* OperatorDef::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:mace.OperatorDef.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mace.OperatorDef.type)
}

// repeated .mace.Argument arg = 5;
inline int OperatorDef::arg_size() const {
  return arg_.size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline const ::mace::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.arg)
  return arg_.Get(index);
}
inline ::mace::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::mace::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.arg)
  return arg_;
}

// repeated .mace.OutputShape output_shape = 6;
inline int OperatorDef::output_shape_size() const {
  return output_shape_.size();
}
inline void OperatorDef::clear_output_shape() {
  output_shape_.Clear();
}
inline const ::mace::OutputShape& OperatorDef::output_shape(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output_shape)
  return output_shape_.Get(index);
}
inline ::mace::OutputShape* OperatorDef::mutable_output_shape(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.output_shape)
  return output_shape_.Mutable(index);
}
inline ::mace::OutputShape* OperatorDef::add_output_shape() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output_shape)
  return output_shape_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::OutputShape >*
OperatorDef::mutable_output_shape() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output_shape)
  return &output_shape_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::OutputShape >&
OperatorDef::output_shape() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output_shape)
  return output_shape_;
}

// repeated .mace.DataType output_type = 7;
inline int OperatorDef::output_type_size() const {
  return output_type_.size();
}
inline void OperatorDef::clear_output_type() {
  output_type_.Clear();
}
inline ::mace::DataType OperatorDef::output_type(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.output_type)
  return static_cast< ::mace::DataType >(output_type_.Get(index));
}
inline void OperatorDef::set_output_type(int index, ::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  output_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.output_type)
}
inline void OperatorDef::add_output_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  output_type_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.output_type)
}
inline const ::google::protobuf::RepeatedField<int>&
OperatorDef::output_type() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.output_type)
  return output_type_;
}
inline ::google::protobuf::RepeatedField<int>*
OperatorDef::mutable_output_type() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.output_type)
  return &output_type_;
}

// repeated int32 mem_id = 10;
inline int OperatorDef::mem_id_size() const {
  return mem_id_.size();
}
inline void OperatorDef::clear_mem_id() {
  mem_id_.Clear();
}
inline ::google::protobuf::int32 OperatorDef::mem_id(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.mem_id)
  return mem_id_.Get(index);
}
inline void OperatorDef::set_mem_id(int index, ::google::protobuf::int32 value) {
  mem_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.mem_id)
}
inline void OperatorDef::add_mem_id(::google::protobuf::int32 value) {
  mem_id_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.mem_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OperatorDef::mem_id() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.mem_id)
  return mem_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OperatorDef::mutable_mem_id() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.mem_id)
  return &mem_id_;
}

// optional uint32 node_id = 100;
inline bool OperatorDef::has_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OperatorDef::set_has_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OperatorDef::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OperatorDef::clear_node_id() {
  node_id_ = 0u;
  clear_has_node_id();
}
inline ::google::protobuf::uint32 OperatorDef::node_id() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.node_id)
  return node_id_;
}
inline void OperatorDef::set_node_id(::google::protobuf::uint32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.node_id)
}

// optional uint32 op_id = 101;
inline bool OperatorDef::has_op_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OperatorDef::set_has_op_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OperatorDef::clear_has_op_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OperatorDef::clear_op_id() {
  op_id_ = 0u;
  clear_has_op_id();
}
inline ::google::protobuf::uint32 OperatorDef::op_id() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.op_id)
  return op_id_;
}
inline void OperatorDef::set_op_id(::google::protobuf::uint32 value) {
  set_has_op_id();
  op_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.op_id)
}

// optional uint32 padding = 102;
inline bool OperatorDef::has_padding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OperatorDef::set_has_padding() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OperatorDef::clear_has_padding() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OperatorDef::clear_padding() {
  padding_ = 0u;
  clear_has_padding();
}
inline ::google::protobuf::uint32 OperatorDef::padding() const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.padding)
  return padding_;
}
inline void OperatorDef::set_padding(::google::protobuf::uint32 value) {
  set_has_padding();
  padding_ = value;
  // @@protoc_insertion_point(field_set:mace.OperatorDef.padding)
}

// repeated .mace.NodeInput node_input = 103;
inline int OperatorDef::node_input_size() const {
  return node_input_.size();
}
inline void OperatorDef::clear_node_input() {
  node_input_.Clear();
}
inline const ::mace::NodeInput& OperatorDef::node_input(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.node_input)
  return node_input_.Get(index);
}
inline ::mace::NodeInput* OperatorDef::mutable_node_input(int index) {
  // @@protoc_insertion_point(field_mutable:mace.OperatorDef.node_input)
  return node_input_.Mutable(index);
}
inline ::mace::NodeInput* OperatorDef::add_node_input() {
  // @@protoc_insertion_point(field_add:mace.OperatorDef.node_input)
  return node_input_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::NodeInput >*
OperatorDef::mutable_node_input() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.node_input)
  return &node_input_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::NodeInput >&
OperatorDef::node_input() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.node_input)
  return node_input_;
}

// repeated int32 out_max_byte_size = 104;
inline int OperatorDef::out_max_byte_size_size() const {
  return out_max_byte_size_.size();
}
inline void OperatorDef::clear_out_max_byte_size() {
  out_max_byte_size_.Clear();
}
inline ::google::protobuf::int32 OperatorDef::out_max_byte_size(int index) const {
  // @@protoc_insertion_point(field_get:mace.OperatorDef.out_max_byte_size)
  return out_max_byte_size_.Get(index);
}
inline void OperatorDef::set_out_max_byte_size(int index, ::google::protobuf::int32 value) {
  out_max_byte_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OperatorDef.out_max_byte_size)
}
inline void OperatorDef::add_out_max_byte_size(::google::protobuf::int32 value) {
  out_max_byte_size_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OperatorDef.out_max_byte_size)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OperatorDef::out_max_byte_size() const {
  // @@protoc_insertion_point(field_list:mace.OperatorDef.out_max_byte_size)
  return out_max_byte_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OperatorDef::mutable_out_max_byte_size() {
  // @@protoc_insertion_point(field_mutable_list:mace.OperatorDef.out_max_byte_size)
  return &out_max_byte_size_;
}

// -------------------------------------------------------------------

// MemoryBlock

// optional int32 mem_id = 1;
inline bool MemoryBlock::has_mem_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MemoryBlock::set_has_mem_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MemoryBlock::clear_has_mem_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MemoryBlock::clear_mem_id() {
  mem_id_ = 0;
  clear_has_mem_id();
}
inline ::google::protobuf::int32 MemoryBlock::mem_id() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.mem_id)
  return mem_id_;
}
inline void MemoryBlock::set_mem_id(::google::protobuf::int32 value) {
  set_has_mem_id();
  mem_id_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.mem_id)
}

// optional uint32 x = 2;
inline bool MemoryBlock::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MemoryBlock::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MemoryBlock::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MemoryBlock::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 MemoryBlock::x() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.x)
  return x_;
}
inline void MemoryBlock::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.x)
}

// optional uint32 y = 3;
inline bool MemoryBlock::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MemoryBlock::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MemoryBlock::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MemoryBlock::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 MemoryBlock::y() const {
  // @@protoc_insertion_point(field_get:mace.MemoryBlock.y)
  return y_;
}
inline void MemoryBlock::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mace.MemoryBlock.y)
}

// -------------------------------------------------------------------

// MemoryArena

// repeated .mace.MemoryBlock mem_block = 1;
inline int MemoryArena::mem_block_size() const {
  return mem_block_.size();
}
inline void MemoryArena::clear_mem_block() {
  mem_block_.Clear();
}
inline const ::mace::MemoryBlock& MemoryArena::mem_block(int index) const {
  // @@protoc_insertion_point(field_get:mace.MemoryArena.mem_block)
  return mem_block_.Get(index);
}
inline ::mace::MemoryBlock* MemoryArena::mutable_mem_block(int index) {
  // @@protoc_insertion_point(field_mutable:mace.MemoryArena.mem_block)
  return mem_block_.Mutable(index);
}
inline ::mace::MemoryBlock* MemoryArena::add_mem_block() {
  // @@protoc_insertion_point(field_add:mace.MemoryArena.mem_block)
  return mem_block_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >*
MemoryArena::mutable_mem_block() {
  // @@protoc_insertion_point(field_mutable_list:mace.MemoryArena.mem_block)
  return &mem_block_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::MemoryBlock >&
MemoryArena::mem_block() const {
  // @@protoc_insertion_point(field_list:mace.MemoryArena.mem_block)
  return mem_block_;
}

// -------------------------------------------------------------------

// InputInfo

// optional string name = 1;
inline bool InputInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InputInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InputInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InputInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& InputInfo::name() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.name)
  return name_.GetNoArena();
}
inline void InputInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.InputInfo.name)
}
#if LANG_CXX11
inline void InputInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.InputInfo.name)
}
#endif
inline void InputInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.InputInfo.name)
}
inline void InputInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.InputInfo.name)
}
inline ::std::string* InputInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.InputInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputInfo::release_name() {
  // @@protoc_insertion_point(field_release:mace.InputInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.InputInfo.name)
}

// optional int32 node_id = 2;
inline bool InputInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputInfo::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 InputInfo::node_id() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.node_id)
  return node_id_;
}
inline void InputInfo::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.node_id)
}

// repeated int32 dims = 3;
inline int InputInfo::dims_size() const {
  return dims_.size();
}
inline void InputInfo::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int32 InputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.dims)
  return dims_.Get(index);
}
inline void InputInfo::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.InputInfo.dims)
}
inline void InputInfo::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.InputInfo.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InputInfo::dims() const {
  // @@protoc_insertion_point(field_list:mace.InputInfo.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.InputInfo.dims)
  return &dims_;
}

// optional int32 max_byte_size = 4;
inline bool InputInfo::has_max_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputInfo::set_has_max_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputInfo::clear_has_max_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputInfo::clear_max_byte_size() {
  max_byte_size_ = 0;
  clear_has_max_byte_size();
}
inline ::google::protobuf::int32 InputInfo::max_byte_size() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.max_byte_size)
  return max_byte_size_;
}
inline void InputInfo::set_max_byte_size(::google::protobuf::int32 value) {
  set_has_max_byte_size();
  max_byte_size_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.max_byte_size)
}

// optional .mace.DataType data_type = 5 [default = DT_FLOAT];
inline bool InputInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InputInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InputInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InputInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::mace::DataType InputInfo::data_type() const {
  // @@protoc_insertion_point(field_get:mace.InputInfo.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
inline void InputInfo::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.InputInfo.data_type)
}

// -------------------------------------------------------------------

// OutputInfo

// optional string name = 1;
inline bool OutputInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OutputInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OutputInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OutputInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& OutputInfo::name() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.name)
  return name_.GetNoArena();
}
inline void OutputInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.OutputInfo.name)
}
#if LANG_CXX11
inline void OutputInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.OutputInfo.name)
}
#endif
inline void OutputInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.OutputInfo.name)
}
inline void OutputInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.OutputInfo.name)
}
inline ::std::string* OutputInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.OutputInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OutputInfo::release_name() {
  // @@protoc_insertion_point(field_release:mace.OutputInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutputInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.OutputInfo.name)
}

// optional int32 node_id = 2;
inline bool OutputInfo::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OutputInfo::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OutputInfo::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OutputInfo::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 OutputInfo::node_id() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.node_id)
  return node_id_;
}
inline void OutputInfo::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.node_id)
}

// repeated int32 dims = 3;
inline int OutputInfo::dims_size() const {
  return dims_.size();
}
inline void OutputInfo::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int32 OutputInfo::dims(int index) const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.dims)
  return dims_.Get(index);
}
inline void OutputInfo::set_dims(int index, ::google::protobuf::int32 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:mace.OutputInfo.dims)
}
inline void OutputInfo::add_dims(::google::protobuf::int32 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:mace.OutputInfo.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
OutputInfo::dims() const {
  // @@protoc_insertion_point(field_list:mace.OutputInfo.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
OutputInfo::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:mace.OutputInfo.dims)
  return &dims_;
}

// optional int32 max_byte_size = 4;
inline bool OutputInfo::has_max_byte_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OutputInfo::set_has_max_byte_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OutputInfo::clear_has_max_byte_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OutputInfo::clear_max_byte_size() {
  max_byte_size_ = 0;
  clear_has_max_byte_size();
}
inline ::google::protobuf::int32 OutputInfo::max_byte_size() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.max_byte_size)
  return max_byte_size_;
}
inline void OutputInfo::set_max_byte_size(::google::protobuf::int32 value) {
  set_has_max_byte_size();
  max_byte_size_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.max_byte_size)
}

// optional .mace.DataType data_type = 5 [default = DT_FLOAT];
inline bool OutputInfo::has_data_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OutputInfo::set_has_data_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OutputInfo::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OutputInfo::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::mace::DataType OutputInfo::data_type() const {
  // @@protoc_insertion_point(field_get:mace.OutputInfo.data_type)
  return static_cast< ::mace::DataType >(data_type_);
}
inline void OutputInfo::set_data_type(::mace::DataType value) {
  assert(::mace::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:mace.OutputInfo.data_type)
}

// -------------------------------------------------------------------

// NetDef

// optional string name = 1;
inline bool NetDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& NetDef::name() const {
  // @@protoc_insertion_point(field_get:mace.NetDef.name)
  return name_.GetNoArena();
}
inline void NetDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.NetDef.name)
}
#if LANG_CXX11
inline void NetDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.NetDef.name)
}
#endif
inline void NetDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.NetDef.name)
}
inline void NetDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.NetDef.name)
}
inline ::std::string* NetDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mace.NetDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_name() {
  // @@protoc_insertion_point(field_release:mace.NetDef.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.name)
}

// repeated .mace.OperatorDef op = 2;
inline int NetDef::op_size() const {
  return op_.size();
}
inline void NetDef::clear_op() {
  op_.Clear();
}
inline const ::mace::OperatorDef& NetDef::op(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.op)
  return op_.Get(index);
}
inline ::mace::OperatorDef* NetDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.op)
  return op_.Mutable(index);
}
inline ::mace::OperatorDef* NetDef::add_op() {
  // @@protoc_insertion_point(field_add:mace.NetDef.op)
  return op_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >*
NetDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.op)
  return &op_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::OperatorDef >&
NetDef::op() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.op)
  return op_;
}

// optional string version = 3;
inline bool NetDef::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetDef::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetDef::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetDef::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
inline const ::std::string& NetDef::version() const {
  // @@protoc_insertion_point(field_get:mace.NetDef.version)
  return version_.GetNoArena();
}
inline void NetDef::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mace.NetDef.version)
}
#if LANG_CXX11
inline void NetDef::set_version(::std::string&& value) {
  set_has_version();
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mace.NetDef.version)
}
#endif
inline void NetDef::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mace.NetDef.version)
}
inline void NetDef::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mace.NetDef.version)
}
inline ::std::string* NetDef::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mace.NetDef.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDef::release_version() {
  // @@protoc_insertion_point(field_release:mace.NetDef.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.version)
}

// repeated .mace.Argument arg = 4;
inline int NetDef::arg_size() const {
  return arg_.size();
}
inline void NetDef::clear_arg() {
  arg_.Clear();
}
inline const ::mace::Argument& NetDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.arg)
  return arg_.Get(index);
}
inline ::mace::Argument* NetDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.arg)
  return arg_.Mutable(index);
}
inline ::mace::Argument* NetDef::add_arg() {
  // @@protoc_insertion_point(field_add:mace.NetDef.arg)
  return arg_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::Argument >*
NetDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.arg)
  return &arg_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::Argument >&
NetDef::arg() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.arg)
  return arg_;
}

// repeated .mace.ConstTensor tensors = 5;
inline int NetDef::tensors_size() const {
  return tensors_.size();
}
inline void NetDef::clear_tensors() {
  tensors_.Clear();
}
inline const ::mace::ConstTensor& NetDef::tensors(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.tensors)
  return tensors_.Get(index);
}
inline ::mace::ConstTensor* NetDef::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.tensors)
  return tensors_.Mutable(index);
}
inline ::mace::ConstTensor* NetDef::add_tensors() {
  // @@protoc_insertion_point(field_add:mace.NetDef.tensors)
  return tensors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >*
NetDef::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.tensors)
  return &tensors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::ConstTensor >&
NetDef::tensors() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.tensors)
  return tensors_;
}

// optional .mace.MemoryArena mem_arena = 10;
inline bool NetDef::has_mem_arena() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetDef::set_has_mem_arena() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetDef::clear_has_mem_arena() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetDef::clear_mem_arena() {
  if (mem_arena_ != NULL) mem_arena_->::mace::MemoryArena::Clear();
  clear_has_mem_arena();
}
inline const ::mace::MemoryArena& NetDef::mem_arena() const {
  const ::mace::MemoryArena* p = mem_arena_;
  // @@protoc_insertion_point(field_get:mace.NetDef.mem_arena)
  return p != NULL ? *p : *reinterpret_cast<const ::mace::MemoryArena*>(
      &::mace::_MemoryArena_default_instance_);
}
inline ::mace::MemoryArena* NetDef::mutable_mem_arena() {
  set_has_mem_arena();
  if (mem_arena_ == NULL) {
    mem_arena_ = new ::mace::MemoryArena;
  }
  // @@protoc_insertion_point(field_mutable:mace.NetDef.mem_arena)
  return mem_arena_;
}
inline ::mace::MemoryArena* NetDef::release_mem_arena() {
  // @@protoc_insertion_point(field_release:mace.NetDef.mem_arena)
  clear_has_mem_arena();
  ::mace::MemoryArena* temp = mem_arena_;
  mem_arena_ = NULL;
  return temp;
}
inline void NetDef::set_allocated_mem_arena(::mace::MemoryArena* mem_arena) {
  delete mem_arena_;
  mem_arena_ = mem_arena;
  if (mem_arena) {
    set_has_mem_arena();
  } else {
    clear_has_mem_arena();
  }
  // @@protoc_insertion_point(field_set_allocated:mace.NetDef.mem_arena)
}

// repeated .mace.InputInfo input_info = 100;
inline int NetDef::input_info_size() const {
  return input_info_.size();
}
inline void NetDef::clear_input_info() {
  input_info_.Clear();
}
inline const ::mace::InputInfo& NetDef::input_info(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.input_info)
  return input_info_.Get(index);
}
inline ::mace::InputInfo* NetDef::mutable_input_info(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.input_info)
  return input_info_.Mutable(index);
}
inline ::mace::InputInfo* NetDef::add_input_info() {
  // @@protoc_insertion_point(field_add:mace.NetDef.input_info)
  return input_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::InputInfo >*
NetDef::mutable_input_info() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.input_info)
  return &input_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::InputInfo >&
NetDef::input_info() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.input_info)
  return input_info_;
}

// repeated .mace.OutputInfo output_info = 101;
inline int NetDef::output_info_size() const {
  return output_info_.size();
}
inline void NetDef::clear_output_info() {
  output_info_.Clear();
}
inline const ::mace::OutputInfo& NetDef::output_info(int index) const {
  // @@protoc_insertion_point(field_get:mace.NetDef.output_info)
  return output_info_.Get(index);
}
inline ::mace::OutputInfo* NetDef::mutable_output_info(int index) {
  // @@protoc_insertion_point(field_mutable:mace.NetDef.output_info)
  return output_info_.Mutable(index);
}
inline ::mace::OutputInfo* NetDef::add_output_info() {
  // @@protoc_insertion_point(field_add:mace.NetDef.output_info)
  return output_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >*
NetDef::mutable_output_info() {
  // @@protoc_insertion_point(field_mutable_list:mace.NetDef.output_info)
  return &output_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mace::OutputInfo >&
NetDef::output_info() const {
  // @@protoc_insertion_point(field_list:mace.NetDef.output_info)
  return output_info_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace mace

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mace::NetMode> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mace::DataType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mace_2fproto_2fmace_2eproto__INCLUDED
